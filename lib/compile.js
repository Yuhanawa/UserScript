const sass = require('sass');
const csso = require('csso');
const uglifyJs = require('uglify-js');

const fs = require('fs');
const yaml = require('js-yaml');
const path = require('path');
const template = require('art-template');


let currentName;
let config = {}


/**
 * @deprecated will be removed in the future
 */
function transfer(script) {
    currentName = script.name;
    config = script.config
}

/**
 * Returns the content generated by applying the data to the userScript.art template.
 *
 * @param data - The data to apply to the template.
 * @return {string} The generated content.
 */
function getContent(data) {
    return template(path.join(__dirname, 'template', 'Main.art'), data);
}

/**
 * Writes the output to a file and returns the file path and output.
 *
 * @param {string} output - The output to be written to the file.
 * @return {{outpath,output}} An object containing the file path and output.
 */
function output2file(output) {
    if (!fs.existsSync("out")) fs.mkdirSync("out");

    const outpath = path.join("out", currentName + ".js");

    fs.writeFileSync(outpath, output);
    return { outpath, output }
}

/**
 * Process the features in the given JavaScript code.
 *
 * @param {string} js - The JavaScript code to process.
 * @param {string} selfpath - The path to the current file.
 */
function processingFeatures(js, selfpath) {
    if (js === "") return "";

    const key = path.basename(selfpath, '.js');

    // Replace all occurrences of $CSS(...) with the minified CSS content
    const regex_CSS = /\$CSS\((.+?)\)/g;
    js = js.replace(regex_CSS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .css, add the extension
        if (!fileName.endsWith('.css')) fileName += '.css';
        // Get the full path to the CSS file
        const fullPath = path.join("src", currentName, 'style', fileName);
        // Read the content of the file
        const content = fs.readFileSync(fullPath, 'utf8');
        // Minify the CSS content using csso
        const minified = csso.minify(content).css;

        return `"${minified}"`;
    });

    // Replace all occurrences of $SASS(...) with the minified SASS content
    const regex_SASS = /\$SASS\((.+?)\)/g;
    js = js.replace(regex_SASS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .sass, add the extension
        if (!fileName.endsWith('.sass')) fileName += '.sass';
        // Get the full path to the SASS file
        fullPath = path.join("src", currentName, 'style', fileName);
        let replaces = "";
        // Minify the SASS content and replace $get(...) functions
        const result = `'${csso.minify(sass.compile(fullPath).css).css}'`
            .replace(/(\"\s*\$get\([^)\n]+\)\s*\")/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match.substring(1, match.length - 1).trim()})`;
                return key;
            })
            .replace(/(\$get\([^)\n]+\))/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match})`;
                return key;
            });

        return result + replaces;
    });

    // Return the processed JavaScript code
    return `${currentName}_${key}: { name:'${js.replace(',', "',match:").replace(/]\s*,/, "],values:")} },`;
}

function beta_processingFeatures(fileContent, selfpath) {
    if (fileContent === "") return "";

    const key = path.basename(selfpath, '.js').replaceAll(' ', '_');

    fileContent = fileContent.replace(/\n *,/, '\n,')
    const splits = fileContent.split('\n,')
    const info = loadFileInfo(splits[0])
    let js = splits.slice(1).join('\n,')


    // Replace all occurrences of $CSS(...) with the minified CSS content
    const regex_CSS = /\$CSS\((.+?)\)/g;
    js = js.replace(regex_CSS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .css, add the extension
        if (!fileName.endsWith('.css')) fileName += '.css';
        // Get the full path to the CSS file
        const fullPath = path.join("src", currentName, 'style', fileName);
        // Read the content of the file
        const content = fs.readFileSync(fullPath, 'utf8');
        // Minify the CSS content using csso
        const minified = csso.minify(content).css;

        return `"${minified}"`;
    });

    // Replace all occurrences of $SASS(...) with the minified SASS content
    const regex_SASS = /\$SASS\((.+?)\)/g;
    js = js.replace(regex_SASS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .sass, add the extension
        if (!fileName.endsWith('.sass')) fileName += '.sass';
        // Get the full path to the SASS file
        fullPath = path.join("src", currentName, 'style', fileName);
        let replaces = "";
        // Minify the SASS content and replace $get(...) functions
        const result = `'${csso.minify(sass.compile(fullPath).css).css}'`
            .replace(/(\"\s*\$get\([^)\n]+\)\s*\")/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match.substring(1, match.length - 1).trim()})`;
                return key;
            })
            .replace(/(\$get\([^)\n]+\))/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match})`;
                return key;
            });

        return result + replaces;
    });

    // Return the processed JavaScript code
    return `${currentName}_${key}: ${JSON.stringify({ ...info, ...{ values: "{{values}}" } })
        .replace('"{{values}}"', js)
        .replaceAll("\"{{REMOVELEFTQUOTE}}", '').replaceAll('{{REMOVERIGHTQUOTE}}\"', '')
        .replaceAll('\\\\', '\\')
        }`;
}

function loadFileInfo(yamlStr) {
    // remove //... or /* */ in yamlStr
    yamlStr = yamlStr.replaceAll(/((?<!\\)\/\/.*|\/\*[\s\S]*?\*\/)/g, '');
    let info = yaml.load(yamlStr);

    if (!info.match || ['.', '*', ['*'], ['.']].includes(info.match)) {
        info.match = true;
    } else {
        function processStr(str) {
            return `{{REMOVELEFTQUOTE}}${str}{{REMOVERIGHTQUOTE}}`
        }
        if (typeof info.match === 'string') {
            if (info.match.startsWith('/') && info.match.endsWith('/')) {
                info.match = [processStr(item)];
            } else info.match = [info.match];
        } else if (Array.isArray(info.match)) {
            const newMatch = [];
            for (const item of info.match) {
                if (typeof item === 'string') {
                    if (item.startsWith('/') && item.endsWith('/')) {
                        newMatch.push(processStr(item));
                    } else newMatch.push(item);
                } else newMatch.push(item);
            }
            info.match = newMatch;
        }
    }

    return info;
}



/**
 * Minify the code using uglifyJs library with specified options.
 *
 * @param {string} js - The JavaScript code to be minified.
 * @returns {string} The minified JavaScript code.
 */
function uglify(js) {
    // Minify the code using uglifyJs library with specified options
    const result = uglifyJs.minify(js, {
        mangle: false, // Do not mangle variable and function names
        output: {
            comments: config.keepComments, // Keep comments that start with '!'
        },
    });

    if (result.error) {
        // èŽ·å–é”™è¯¯è¡Œå‰ 2 è¡Œåˆ°åŽ 3 è¡Œçš„ä»£ç 
        const startLine = Math.max(result.error.line - 2, 0);
        const endLine = result.error.line + 3;
        const errorLines = js.split('\n').slice(startLine, endLine);

        console.error(`--- a error occurred ---`);
        console.error(errorLines.join('\n'));
        console.error(result.error.message);

        throw result.error;
    }

    return result.code;
}

// çŽ°åœ¨åªæœ‰ä¸Šå¸çŸ¥é“ä»–æ˜¯å¹²å•¥çš„äº†
// now we only have God knows what he is doing
function getRandomKey() {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    const charactersLength = characters.length;
    for (let i = 0; i < 6; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }

    return 'ðŸ”‘' + result;
}



module.exports = {
    uglify,
    beta_processingFeatures,
    processingFeatures,
    getContent, transfer, output2file
}
