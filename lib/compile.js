const sass = require('sass');
const csso = require('csso');
const uglifyJs = require('uglify-js');

const fs = require('fs');
const yaml = require('js-yaml');
const path = require('path');
const template = require('art-template');


let currentName;
let config = {}


/**
 * @deprecated will be removed in the future
 */
function transfer(script) {
    currentName = script.name;
    config = script.config
}

/**
 * Returns the content generated by applying the data to the userScript.art template.
 *
 * @param data - The data to apply to the template.
 * @return {string} The generated content.
 */
function getContent(data) {
    return template(path.join(__dirname, 'template', 'Main.art'), data);
}

/**
 * Writes the output to a file and returns the file path and output.
 *
 * @param {string} output - The output to be written to the file.
 * @return {{outpath,output}} An object containing the file path and output.
 */
function output2file(output) {
    if (!fs.existsSync("out")) fs.mkdirSync("out");

    const outpath = path.join("out", currentName + ".js");

    fs.writeFileSync(outpath, output);
    return { outpath, output }
}

/**
 * Process the features in the given JavaScript code.
 *
 * @param {string} js - The JavaScript code to process.
 * @param {string} selfpath - The path to the current file.
 */
function processingFeatures(js, selfpath) {
    if (js === "") return "";

    const key = path.basename(selfpath, '.js');

    // Replace all occurrences of $CSS(...) with the minified CSS content
    const regex_CSS = /\$CSS\((.+?)\)/g;
    js = js.replace(regex_CSS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .css, add the extension
        if (!fileName.endsWith('.css')) fileName += '.css';
        // Get the full path to the CSS file
        const fullPath = path.join("src", currentName, 'style', fileName);
        // Read the content of the file
        const content = fs.readFileSync(fullPath, 'utf8');
        // Minify the CSS content using csso
        const minified = csso.minify(content).css;

        return `"${minified}"`;
    });

    // Replace all occurrences of $SASS(...) with the minified SASS content
    const regex_SASS = /\$SASS\((.+?)\)/g;
    js = js.replace(regex_SASS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .sass, add the extension
        if (!fileName.endsWith('.sass')) fileName += '.sass';
        // Get the full path to the SASS file
        fullPath = path.join("src", currentName, 'style', fileName);
        let replaces = "";
        // Minify the SASS content and replace $get(...) functions
        const result = `'${csso.minify(sass.compile(fullPath).css).css}'`
            .replace(/(\"\s*\$get\([^)\n]+\)\s*\")/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match.substring(1, match.length - 1).trim()})`;
                return key;
            })
            .replace(/(\$get\([^)\n]+\))/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match})`;
                return key;
            });

        return result + replaces;
    });

    // Return the processed JavaScript code
    return `${currentName}_${key}: { name:'${js.replace(',', "',match:").replace(/]\s*,/, "],values:")} },`;
}

function beta_processingFeatures(fileContent, selfpath) {
    if (fileContent === "") return "";

    const key = path.basename(selfpath, '.js');

    const splits = fileContent.split('\n,')
    const info = yaml.load(splits[0])
    let js = splits.slice(1).join('\n,')


    // Replace all occurrences of $CSS(...) with the minified CSS content
    const regex_CSS = /\$CSS\((.+?)\)/g;
    js = js.replace(regex_CSS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .css, add the extension
        if (!fileName.endsWith('.css')) fileName += '.css';
        // Get the full path to the CSS file
        const fullPath = path.join("src", currentName, 'style', fileName);
        // Read the content of the file
        const content = fs.readFileSync(fullPath, 'utf8');
        // Minify the CSS content using csso
        const minified = csso.minify(content).css;

        return `"${minified}"`;
    });

    // Replace all occurrences of $SASS(...) with the minified SASS content
    const regex_SASS = /\$SASS\((.+?)\)/g;
    js = js.replace(regex_SASS, (_match, fileName) => {
        // Remove any spaces, double quotes, and single quotes from the file name
        fileName = fileName.replaceAll(' ', '').replaceAll('"', '').replaceAll("'", '');
        // If the file name does not end with .sass, add the extension
        if (!fileName.endsWith('.sass')) fileName += '.sass';
        // Get the full path to the SASS file
        fullPath = path.join("src", currentName, 'style', fileName);
        let replaces = "";
        // Minify the SASS content and replace $get(...) functions
        const result = `'${csso.minify(sass.compile(fullPath).css).css}'`
            .replace(/(\"\s*\$get\([^)\n]+\)\s*\")/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match.substring(1, match.length - 1).trim()})`;
                return key;
            })
            .replace(/(\$get\([^)\n]+\))/gi, (match) => {
                const key = getRandomKey();
                replaces += `.replace('${key}',${match})`;
                return key;
            });

        return result + replaces;
    });

    // Return the processed JavaScript code
    return `${currentName}_${key}: ${JSON.stringify({
        name: info.name,
        match: info.match,
        values: "{{values}}"
    }).replace('"{{values}}"', js)}`;
}

/**
 * Minify the code using uglifyJs library with specified options.
 *
 * @param {string} js - The JavaScript code to be minified.
 * @returns {string} The minified JavaScript code.
 */
function uglify(js) {
    // Minify the code using uglifyJs library with specified options
    const result = uglifyJs.minify(js, {
        mangle: false, // Do not mangle variable and function names
        output: {
            comments: config.keepComments, // Keep comments that start with '!'
        },
    });

    if (result.error) {
        // 获取错误行前 2 行到后 3 行的代码
        const startLine = Math.max(result.error.line - 2, 0);
        const endLine = result.error.line + 3;
        const errorLines = js.split('\n').slice(startLine, endLine);

        console.error(`--- a error occurred ---`);
        console.error(errorLines.join('\n'));
        console.error(result.error.message);

        throw result.error;
    }

    return result.code;
}

// 现在只有上帝知道他是干啥的了
// now we only have God knows what he is doing
function getRandomKey() {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    const charactersLength = characters.length;
    for (let i = 0; i < 6; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }

    return '🔑' + result;
}



module.exports = {
    uglify,
    beta_processingFeatures,
    processingFeatures,
    getContent, transfer, output2file
}
